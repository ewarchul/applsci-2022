set VERT;
set ARCS;
set STREAMS;
set VEHICLES;
set DIM;
set LOG_FUN ordered;
set DELAYS ordered;
set ARCSE {VERT};
set ARCSL {VERT};
set ARCS_VEHICLE {VEHICLES};
set VEHICLE_ALLOWED {VERT};

param source {STREAMS} symbolic within VERT;
param dest {STREAMS} symbolic within VERT;
param stream_size {STREAMS, DIM}, >=0;
param travel_cost {VEHICLES, ARCS}, >=0;
param function_cost {STREAMS, VERT, LOG_FUN}, >=0;
param travel_time {VEHICLES, ARCS}, >=0;
param function_time {STREAMS, VERT, LOG_FUN}, >=0;
param capacity {VEHICLES, DIM}, >=0;
param gathered {STREAMS} symbolic within STREAMS;
param open_time {VERT}, >=0, <=24;
param close_time {VERT}, >=0, <=24;
param available_time {STREAMS}, >=0, <=24;
param delivery_time {STREAMS}, >=0, <=24;
param max_delay {STREAMS} symbolic within DELAYS;

var X {s in STREAMS, a in ARCS, d in DELAYS, f in LOG_FUN, t in VEHICLES}, integer >=0;
var Y {v in VEHICLES, a in ARCS}, integer >=0;
var Z {s in STREAMS, v in VERT, d in DELAYS, f in LOG_FUN}, integer >=0;
var W {s in STREAMS, v in VERT, d in DELAYS, f in LOG_FUN}, integer >=0;


minimize TotalCost:
sum {t in VEHICLES,a in ARCS} Y[t,a] * travel_cost[t,a] + sum {s in STREAMS, v in VERT, d in DELAYS, f in LOG_FUN: f <> first(LOG_FUN)} W[s,v,d,f] * function_cost[s,v,f];

subject to FlowConstraint {s in STREAMS, v in VERT, f in LOG_FUN, d in DELAYS:  ord(d,DELAYS) >= ord(max_delay[s],DELAYS) and d <> last(DELAYS)}:
sum {t in VEHICLES, a in ARCSE[v]} X[s,a,d,f,t] - sum {t in VEHICLES, a in ARCSL[v]} X[s,a,d,f,t] = Z[s,v,next(d,DELAYS),f] - Z[s,v,d,f] + (if f <> last(LOG_FUN) then W[s,v,d,next(f,LOG_FUN)]) - W[s,v,d,f];

subject to VehicleConstraint {a in ARCS, m in DIM, t in VEHICLES}:
sum {s in STREAMS, d in DELAYS, f in LOG_FUN} X[s,a,d,f,t] * stream_size[s,m] <= Y[t,a] * capacity[t,m];

subject to NetworkConstraint {s in STREAMS}:
Z[s, source[s], max_delay[s], first(LOG_FUN)] = 1;

subject to VertexConstraint {s in STREAMS, f in LOG_FUN, v in VERT: v <> dest[s]}:
Z[s,v, last(DELAYS), f] = 0;

subject to LogicalConstraint {s in STREAMS, f in LOG_FUN: f <> last(LOG_FUN)}:
Z[s, dest[s], last(DELAYS), f] = 0;

subject to GatheredConstraintMove {s in STREAMS, a in ARCS, d1 in DELAYS, d2 in DELAYS, t in VEHICLES: ord(d1,DELAYS) - ord(d2,DELAYS) = ord(max_delay[s],DELAYS) - ord(max_delay[gathered[s]],DELAYS)}:
X[s,a,d1,first(LOG_FUN),t] = X[gathered[s],a,d2,first(LOG_FUN),t];

subject to GatheredConstraintSort {s in STREAMS, v in VERT, d1 in DELAYS, d2 in DELAYS: ord(d1,DELAYS) - ord(d2,DELAYS) = ord(max_delay[s],DELAYS) - ord(max_delay[gathered[s]],DELAYS)}:
W[s,v,d1,first(LOG_FUN)] = W[gathered[s],v,d2,first(LOG_FUN)];

subject to GeneralTimeConstraint {s in STREAMS, d in DELAYS, v1 in VERT, v2 in VERT: d <> last(DELAYS)}:
sum {a in ARCS, f in LOG_FUN, t in VEHICLES} X[s,a,d,f,t] * travel_time[t,a] + sum {v in VERT, f in LOG_FUN: f <> first(LOG_FUN)} W[s,v,d,f] * function_time[s,v,f] <= close_time[v2] - open_time[v1] + 96 - 48 * sum {f in LOG_FUN} (Z[s,v1,d,f] + Z[s,v2,next(d,DELAYS),f]);

subject to AllowedArcs {a in ARCS, t in VEHICLES: a not in ARCS_VEHICLE[t]}:
Y[t,a] = 0;

subject to AllowedVehicles {v in VERT, a in ARCSE[v] union ARCSL[v], t in VEHICLES: t not in VEHICLE_ALLOWED[v]}:
Y[t,a] = 0;
